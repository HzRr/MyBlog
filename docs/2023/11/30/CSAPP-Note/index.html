<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>CSAPP_Note</title>
<meta name="keywords" content="CSAPP_Note, HzRr&#39;s Blog">
<meta name="description" content="[TOC]
第1章 计算机系统漫游…
第2章 信息的表示和处理…
第3章 程序的机器级表示1. 数据格式


C声明
Intel 数据类型
汇编代码后缀
大小（字节）



char
字节
b
1


short
字
w
2


int
双">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="CSAPP_Note">
<meta property="og:description" content="[TOC]
第1章 计算机系统漫游…
第2章 信息的表示和处理…
第3章 程序的机器级表示1. 数据格式


C声明
Intel 数据类型
汇编代码后缀
大小（字节）



char
字节
b
1


short
字
w
2


int
双">

<link rel="shortcut icon" href="/null">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://www.hzrr.com">
        <img class="avatar" src="/images/avatar.svg" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://www.hzrr.com">
        <h1 class="site-title">HzRr&#39;s Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">CSAPP_Note</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-11-30</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Note/">
              Note
                
                  ，
                
              </a>
            
              <a href="/tags/CSAPP/">
              CSAPP
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>[TOC]</p>
<h1 id="第1章-计算机系统漫游"><a href="#第1章-计算机系统漫游" class="headerlink" title="第1章 计算机系统漫游"></a>第1章 计算机系统漫游</h1><p>…</p>
<h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><p>…</p>
<h1 id="第3章-程序的机器级表示"><a href="#第3章-程序的机器级表示" class="headerlink" title="第3章 程序的机器级表示"></a>第3章 程序的机器级表示</h1><h2 id="1-数据格式"><a href="#1-数据格式" class="headerlink" title="1. 数据格式"></a>1. 数据格式</h2><table>
<thead>
<tr>
<th align="center">C声明</th>
<th align="center">Intel 数据类型</th>
<th align="center">汇编代码后缀</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">字节</td>
<td align="center">b</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">字</td>
<td align="center">w</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">双字</td>
<td align="center">l</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char*</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度</td>
<td align="center">s</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度</td>
<td align="center">l</td>
<td align="center">8</td>
</tr>
</tbody></table>
<blockquote>
<p>由于是从16位体系结构扩展成32位的，Intel用术语<strong>字</strong>表示16位数据类型。</p>
</blockquote>
<h2 id="2-访问信息"><a href="#2-访问信息" class="headerlink" title="2. 访问信息"></a>2. 访问信息</h2><p>一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的<em>通用目的寄存器</em>。这些寄存器用来存储<strong>整数数据</strong>和<strong>指针</strong>。</p>
<table>
<thead>
<tr>
<th align="center">64bit</th>
<th align="center">32bit</th>
<th align="center">16bit</th>
<th align="center">8bit</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%rax</td>
<td align="center">%eax</td>
<td align="center">%ax</td>
<td align="center">%al</td>
<td align="center">返回值</td>
</tr>
<tr>
<td align="center">%rbx</td>
<td align="center">%ebx</td>
<td align="center">%bx</td>
<td align="center">%bl</td>
<td align="center">被调用者保存</td>
</tr>
<tr>
<td align="center">%rcx</td>
<td align="center">%ecx</td>
<td align="center">%cx</td>
<td align="center">%cl</td>
<td align="center">第4个参数</td>
</tr>
<tr>
<td align="center">%rdx</td>
<td align="center">%edx</td>
<td align="center">%dx</td>
<td align="center">%dl</td>
<td align="center">第3个参数</td>
</tr>
<tr>
<td align="center">%rsi</td>
<td align="center">%esi</td>
<td align="center">%si</td>
<td align="center">%sil</td>
<td align="center">第2个参数</td>
</tr>
<tr>
<td align="center">%rdi</td>
<td align="center">%edi</td>
<td align="center">%di</td>
<td align="center">%dil</td>
<td align="center">第1个参数</td>
</tr>
<tr>
<td align="center">%rbp</td>
<td align="center">%ebp</td>
<td align="center">%bp</td>
<td align="center">%bpl</td>
<td align="center">被调用者保存</td>
</tr>
<tr>
<td align="center">%rsp</td>
<td align="center">%esp</td>
<td align="center">%sp</td>
<td align="center">%spl</td>
<td align="center">栈指针</td>
</tr>
<tr>
<td align="center">%r8</td>
<td align="center">%r8d</td>
<td align="center">%r8w</td>
<td align="center">%r8b</td>
<td align="center">第5个参数</td>
</tr>
<tr>
<td align="center">%r9</td>
<td align="center">%r9d</td>
<td align="center">%r9w</td>
<td align="center">%r9b</td>
<td align="center">第6个参数</td>
</tr>
<tr>
<td align="center">%r10</td>
<td align="center">%r10d</td>
<td align="center">%r10w</td>
<td align="center">%r10b</td>
<td align="center">调用者保存</td>
</tr>
<tr>
<td align="center">%r11</td>
<td align="center">%r11d</td>
<td align="center">%r11w</td>
<td align="center">%r11b</td>
<td align="center">调用者保存</td>
</tr>
<tr>
<td align="center">%r12</td>
<td align="center">%r12d</td>
<td align="center">%r12w</td>
<td align="center">%r12b</td>
<td align="center">被调用者保存</td>
</tr>
<tr>
<td align="center">%r13</td>
<td align="center">%r13d</td>
<td align="center">%r13w</td>
<td align="center">%r13b</td>
<td align="center">被调用者保存</td>
</tr>
<tr>
<td align="center">%r14</td>
<td align="center">%r14d</td>
<td align="center">%r14w</td>
<td align="center">%r14b</td>
<td align="center">被调用者保存</td>
</tr>
<tr>
<td align="center">%r15</td>
<td align="center">%r15d</td>
<td align="center">%r15w</td>
<td align="center">%r15b</td>
<td align="center">被调用者保存</td>
</tr>
</tbody></table>
<p>对于生成小于8字节结果的指令，有两条规则：</p>
<ul>
<li><p>生成1byte和2byte数字的指令会保持剩下的字节不变。</p>
</li>
<li><p>生成4字节数字的指令会把高位4个字节置为0。</p>
<blockquote>
<p>这条规则是作为从IA32到x86-64的扩展的一部分而采用的。</p>
</blockquote>
</li>
</ul>
<h2 id="3-操作数指示符"><a href="#3-操作数指示符" class="headerlink" title="3. 操作数指示符"></a>3. 操作数指示符</h2><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">格式</th>
<th align="left">操作数值</th>
<th align="left">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">立即数</td>
<td align="left">$Imm</td>
<td align="left">Imm</td>
<td align="left">立即数寻址</td>
</tr>
<tr>
<td align="left">寄存器</td>
<td align="left">r_a</td>
<td align="left">R[r_a]</td>
<td align="left">寄存器寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">Imm</td>
<td align="left">M[Imm]</td>
<td align="left">绝对寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">(r_a)</td>
<td align="left">M[R[r_a]]</td>
<td align="left">间接寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">Imm(r_b)</td>
<td align="left">M[Imm+R[r_b]]</td>
<td align="left">（基址+偏移量）寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">(r_a,r_i)</td>
<td align="left">M[R[r_b]+R[r_i]]</td>
<td align="left">变址寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">Imm(r_b,r_i)</td>
<td align="left">M[Imm+R[r_b]+R[r_i]]</td>
<td align="left">变址寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">(,r_i,s)</td>
<td align="left">M[R[r_i]*s]</td>
<td align="left">比例变址寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">Imm(,r_i,s)</td>
<td align="left">M[Imm+R[r_i]*s]</td>
<td align="left">比例变址寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">(r_b,r_i,s)</td>
<td align="left">M[R[r_b]+R[r_i]*s]</td>
<td align="left">比例变址寻址</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">Imm(r_b,r_i,s)</td>
<td align="left">M[Imm+R[r_b]+R[r_i]*s]</td>
<td align="left">比例变址寻址</td>
</tr>
</tbody></table>
<ul>
<li>用r_a表示任意寄存器a, 用引用R[r_a]来表示它的值，用M_b[Addr]表示对存储在内存中从地址Addr开始的b个字节的引用，为了简便，通常省去下标b。</li>
</ul>
<h2 id="4-数据相关指令"><a href="#4-数据相关指令" class="headerlink" title="4. 数据相关指令"></a>4. 数据相关指令</h2><h3 id="4-1-数据传送指令"><a href="#4-1-数据传送指令" class="headerlink" title="4.1. 数据传送指令"></a>4.1. 数据传送指令</h3><h4 id="4-1-1-MOV类"><a href="#4-1-1-MOV类" class="headerlink" title="4.1.1. MOV类"></a>4.1.1. MOV类</h4><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOV                S,  D</td>
<td align="left">D &lt;- S</td>
<td align="left">传送</td>
</tr>
<tr>
<td align="left">movb</td>
<td align="left"></td>
<td align="left">传送字节</td>
</tr>
<tr>
<td align="left">movw</td>
<td align="left"></td>
<td align="left">传送字</td>
</tr>
<tr>
<td align="left">movl</td>
<td align="left"></td>
<td align="left">传送双字</td>
</tr>
<tr>
<td align="left">movq</td>
<td align="left"></td>
<td align="left">传送四字</td>
</tr>
<tr>
<td align="left">movabsq        I,  R</td>
<td align="left">R &lt;- I</td>
<td align="left">传送绝对的四字</td>
</tr>
</tbody></table>
<ul>
<li>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。</li>
</ul>
<p>​	目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址</p>
<p>​	<strong>注意：</strong> x86-64加了一条限制，传送指令两个操作数<strong>不能都指向内存位置</strong>。(必须先将值传送到寄存器中再传送到目的内存位置)</p>
<ul>
<li>movq指令只能以表示为32为补码数字的<strong>立即数</strong>作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。</li>
</ul>
<p>​	movabsq指令能够以任意64位<strong>立即数</strong>作为源操作数，并且只能以<strong>寄存器</strong>作为目的位置。</p>
<h4 id="4-1-2-MOVZ-MOVS类"><a href="#4-1-2-MOVZ-MOVS类" class="headerlink" title="4.1.2 MOVZ&#x2F;MOVS类"></a>4.1.2 MOVZ&#x2F;MOVS类</h4><table>
<thead>
<tr>
<th align="left">指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOVZ        S,  R</td>
<td>R &lt;- 零扩展(S)</td>
<td>以零扩展进行传送</td>
</tr>
<tr>
<td align="left">movzbw</td>
<td></td>
<td>将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td align="left">movzbl</td>
<td></td>
<td>将做了零扩展的字节传送到双字</td>
</tr>
<tr>
<td align="left">movzwl</td>
<td></td>
<td>将做了零扩展的字传送到双字</td>
</tr>
<tr>
<td align="left">movzbq</td>
<td></td>
<td>将做了零扩展的字节传送到四字</td>
</tr>
<tr>
<td align="left">movzwq</td>
<td></td>
<td>将做了零扩展的字传送到四字</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOVS        S,  R</td>
<td>R &lt;- 符号扩展(S)</td>
<td>以符号扩展进行传送</td>
</tr>
<tr>
<td align="left">movsbw</td>
<td></td>
<td>将做了符号扩展的字节传送到字</td>
</tr>
<tr>
<td align="left">movsbl</td>
<td></td>
<td>将做了符号扩展的字节传送到双字</td>
</tr>
<tr>
<td align="left">movswl</td>
<td></td>
<td>将做了符号扩展的字传送到双字</td>
</tr>
<tr>
<td align="left">movsbq</td>
<td></td>
<td>将做了符号扩展的字节传送到四字</td>
</tr>
<tr>
<td align="left">movswq</td>
<td></td>
<td>将做了符号扩展的字传送到四字</td>
</tr>
<tr>
<td align="left">movslq</td>
<td></td>
<td>将做了符号扩展的双字传送到四字</td>
</tr>
<tr>
<td align="left">cltq</td>
<td>%rax &lt;- 符号扩展(%eax)</td>
<td>把%eax符号扩展到%rax</td>
</tr>
</tbody></table>
<ul>
<li><p>所有这些指令都把数据从源（在寄存器中或内存中）复制到<strong>目的寄存器</strong>。</p>
</li>
<li><p>MOVZ&#x2F;MOVS类区别：</p>
<ol>
<li><p>MOVZ类中的指令把目的中剩余的字节填充为0。</p>
</li>
<li><p>MOVS类中的指令通过符号扩展来填充，目的中的剩余字节填充为源操作数的符号位。</p>
</li>
</ol>
</li>
</ul>
<h3 id="4-2-压入和弹出栈数据"><a href="#4-2-压入和弹出栈数据" class="headerlink" title="4.2. 压入和弹出栈数据"></a>4.2. 压入和弹出栈数据</h3><table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pushq        S</td>
<td>R[%rsp] &lt;- R[%rsp]-8;<br />M[R[%rsp]] &lt;- S</td>
<td>将四字压入栈</td>
</tr>
<tr>
<td>popq          D</td>
<td>D &lt;- M[R[%rsp]];<br />R[%rsp] &lt;- R[%rsp]+8</td>
<td>将四字弹出栈</td>
</tr>
</tbody></table>
<h3 id="4-3-算术和逻辑操作"><a href="#4-3-算术和逻辑操作" class="headerlink" title="4.3. 算术和逻辑操作"></a>4.3. 算术和逻辑操作</h3><table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>leaq        S,  D</td>
<td>D &lt;- &amp;S</td>
<td>加载有效地址</td>
</tr>
<tr>
<td>INC         D</td>
<td>D &lt;- D + 1</td>
<td>加1</td>
</tr>
<tr>
<td>DEC        D</td>
<td>D &lt;- D - 1</td>
<td>减1</td>
</tr>
<tr>
<td>NEG        D</td>
<td>D &lt;- -D</td>
<td>取负</td>
</tr>
<tr>
<td>NOT        D</td>
<td>D &lt;- ~D</td>
<td>取反</td>
</tr>
<tr>
<td>ADD        S,  D</td>
<td>D &lt;- D + S</td>
<td>加</td>
</tr>
<tr>
<td>SUB         S,  D</td>
<td>D &lt;- D - S</td>
<td>减</td>
</tr>
<tr>
<td>IMUL       S,  D</td>
<td>D &lt;- D * S</td>
<td>乘</td>
</tr>
<tr>
<td>XOR         S,  D</td>
<td>D &lt;- D ^ S</td>
<td>异或</td>
</tr>
<tr>
<td>OR           S,  D</td>
<td>D &lt;- D | S</td>
<td>或</td>
</tr>
<tr>
<td>AND        S,  D</td>
<td>D &lt;- D &amp; S</td>
<td>与</td>
</tr>
<tr>
<td>SAL          k,  D</td>
<td>D &lt;- D &lt;&lt; k</td>
<td>左移</td>
</tr>
<tr>
<td>SHL          k,  D</td>
<td>D &lt;- D &lt;&lt; k</td>
<td>左移（等同于SAL）</td>
</tr>
<tr>
<td>SAR          k,  D</td>
<td>D &lt;- D &gt;&gt;_A k</td>
<td>算术右移</td>
</tr>
<tr>
<td>SHR          k,  D</td>
<td>D &lt;- D &gt;&gt;_L k</td>
<td>逻辑右移</td>
</tr>
</tbody></table>
<ul>
<li>除了leaq其他的指令都是指令类，它们有各种带不同大小操作数的变种，如addb, addw, addl, addq.</li>
<li>这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</li>
</ul>
<h3 id="4-4-特殊的算术操作"><a href="#4-4-特殊的算术操作" class="headerlink" title="4.4. 特殊的算术操作"></a>4.4. 特殊的算术操作</h3><p>两个64位整数相乘得到的乘积需要128位来表示。x86-64指令集对128位数的操作提供有限的支持，Intel把16字节的数称为八字(oct word)，以下是相关指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>imulq        S</td>
<td>R[%rdx]:  R[%rax] &lt;- S*R[%rax]</td>
<td>有符号全乘法</td>
</tr>
<tr>
<td>mulq         S</td>
<td>R[%rdx]:  R[%rax] &lt;- S*R[%rax]</td>
<td>无符号全乘法</td>
</tr>
<tr>
<td>cqto</td>
<td>R[%rdx]:  R[%rax] &lt;- 符号扩展(R[%rax])</td>
<td>转换为八字</td>
</tr>
<tr>
<td>idivq         S</td>
<td>R[%rdx] &lt;- R[%rdx]:  R[%rax] mod S<br />R[%rax] &lt;- R[%rdx]:  R[%rax] &#x2F; S</td>
<td>有符号除法</td>
</tr>
<tr>
<td>divq          S</td>
<td>R[%rdx] &lt;- R[%rdx]:  R[%rax] mod S<br />R[%rax] &lt;- R[%rdx]:  R[%rax] &#x2F; S</td>
<td>无符号除法</td>
</tr>
</tbody></table>
<h2 id="5-控制相关指令"><a href="#5-控制相关指令" class="headerlink" title="5. 控制相关指令"></a>5. 控制相关指令</h2><h3 id="5-1-条件码"><a href="#5-1-条件码" class="headerlink" title="5.1. 条件码"></a>5.1. 条件码</h3><p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>的**条件码(condition code)**寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行分支命令。最常用的条件码有：</p>
<ul>
<li><strong>CF:</strong> 进位标志。最近的操作使最高位产生了进位。(可用来检查无符号操作的溢出)</li>
<li><strong>ZF:</strong> 零标志。最近的操作得出的结果位0.</li>
<li><strong>SF:</strong> 符号标志。最近的操作得到的结果位负数。</li>
<li><strong>OF:</strong> 溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。</li>
</ul>
<p>leaq指令不改变任何条件码（因为它是用来进行地址计算的），除此之外<strong>4.3. 算术和逻辑操作</strong>中列出的所有指令都会设置条件码。</p>
<p>例如：</p>
<ul>
<li>逻辑操作，进位标志和溢出标志会被设置为0.</li>
<li>移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0.</li>
<li>INC和DEC指令会设置溢出和零标志。但是不会改变进位标志（[TODO]原因）</li>
</ul>
<p>除了上述指令会设置条件码，还有两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器，如下所示</p>
<table>
<thead>
<tr>
<th>指令类</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CMP        S1,  S2</td>
<td>S2 - S1</td>
<td>比较</td>
</tr>
<tr>
<td>TEST        S1,  S2</td>
<td>S1 &amp; S2</td>
<td>测试</td>
</tr>
</tbody></table>
<h3 id="5-2-访问条件码"><a href="#5-2-访问条件码" class="headerlink" title="5.2. 访问条件码"></a>5.2. 访问条件码</h3><p>一条SET指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成0或1.</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>效果</th>
<th>设置条件</th>
</tr>
</thead>
<tbody><tr>
<td>sete        D</td>
<td>setz</td>
<td>D &lt;- ZF</td>
<td>相等&#x2F;零</td>
</tr>
<tr>
<td>setne      D</td>
<td>setnz</td>
<td>D &lt;- ~ZF</td>
<td>不等&#x2F;非零</td>
</tr>
<tr>
<td>sets         D</td>
<td></td>
<td>D &lt;- SF</td>
<td>负数</td>
</tr>
<tr>
<td>setns       D</td>
<td></td>
<td>D &lt;- ~SF</td>
<td>非负数</td>
</tr>
<tr>
<td>setg         D</td>
<td>setnle</td>
<td>D &lt;- (SF ^ OF) &amp; ~ZF</td>
<td>大于(有符号&gt;)</td>
</tr>
<tr>
<td>setge       D</td>
<td>setnl</td>
<td>D &lt;- ~(SF ^ OF)</td>
<td>大于等于(有符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>setl          D</td>
<td>setnge</td>
<td>D &lt;- SF ^ OF</td>
<td>小于(有符号&lt;)</td>
</tr>
<tr>
<td>setle        D</td>
<td>setng</td>
<td>D &lt;- (SF ^ OF) | ZF</td>
<td>小于等于(有符号&lt;&#x3D;)</td>
</tr>
<tr>
<td>seta         D</td>
<td>setnbe</td>
<td>D &lt;- ~CF &amp; ~ZF</td>
<td>超过(无符号&gt;)</td>
</tr>
<tr>
<td>setae       D</td>
<td>setnb</td>
<td>D &lt;- ~CF</td>
<td>超过或相等(无符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>setb         D</td>
<td>setnae</td>
<td>D &lt;- CF</td>
<td>低于(无符号&lt;)</td>
</tr>
<tr>
<td>setbe       D</td>
<td>setna</td>
<td>D &lt;- CF | ZF</td>
<td>低于或相等(无符号&lt;&#x3D;)</td>
</tr>
</tbody></table>
<h3 id="5-3-跳转指令"><a href="#5-3-跳转指令" class="headerlink" title="5.3. 跳转指令"></a>5.3. 跳转指令</h3><h4 id="5-3-1-jump指令"><a href="#5-3-1-jump指令" class="headerlink" title="5.3.1. jump指令"></a>5.3.1. jump指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jmp        Label</td>
<td></td>
<td>1</td>
<td>直接跳转</td>
</tr>
<tr>
<td>jmp        *Operand</td>
<td></td>
<td>1</td>
<td>间接跳转</td>
</tr>
<tr>
<td>je            Label</td>
<td>jz</td>
<td>ZF</td>
<td>相等&#x2F;零</td>
</tr>
<tr>
<td>jne          Label</td>
<td>jnz</td>
<td>~ZF</td>
<td>不等&#x2F;非零</td>
</tr>
<tr>
<td>js             Label</td>
<td></td>
<td>SF</td>
<td>负数</td>
</tr>
<tr>
<td>jns           Label</td>
<td></td>
<td>~SF</td>
<td>非负数</td>
</tr>
<tr>
<td>jg             Label</td>
<td>jnle</td>
<td>(SF ^ OF) &amp; ~ZF</td>
<td>大于(有符号&gt;)</td>
</tr>
<tr>
<td>jge           Label</td>
<td>jnl</td>
<td>~(SF ^ OF)</td>
<td>大于等于(有符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>jl              Label</td>
<td>jnge</td>
<td>SF ^ OF</td>
<td>小于(有符号&lt;)</td>
</tr>
<tr>
<td>jle            Label</td>
<td>jng</td>
<td>(SF ^ OF) |ZF</td>
<td>小于等于(有符号&lt;&#x3D;)</td>
</tr>
<tr>
<td>ja             Label</td>
<td>jnbe</td>
<td>~CF &amp; ~ZF</td>
<td>超过(无符号&gt;)</td>
</tr>
<tr>
<td>jae           Label</td>
<td>jnb</td>
<td>~CF</td>
<td>超过或相等(无符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>jb             Label</td>
<td>jnae</td>
<td>CF</td>
<td>低于(无符号&lt;)</td>
</tr>
<tr>
<td>jbe           Label</td>
<td>jna</td>
<td>CF |ZF</td>
<td>低于或相等(无符号&lt;&#x3D;)</td>
</tr>
</tbody></table>
<ul>
<li><p>jmp指令是无条件跳转。</p>
<ul>
<li>它可以是<em>直接跳转</em>，即跳转目标是作为指令的一部分编码的。</li>
<li>也可以是<em>间接跳转</em>，即跳转目标是从寄存器或者内存位置中读出的。写法是<code>*</code>后面跟一个操作数指示符。</li>
</ul>
</li>
<li><p>其他跳转指令都是有条件的，<em>条件跳转</em>只能是<em>直接跳转</em>。</p>
</li>
</ul>
<h4 id="5-3-2-跳转指令的编码"><a href="#5-3-2-跳转指令的编码" class="headerlink" title="5.3.2. 跳转指令的编码"></a>5.3.2. 跳转指令的编码</h4><p>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，最常用的是</p>
<ol>
<li><em>PC相对的</em>(PC-relative)：它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些<em>地址偏移量</em>可以编码为1、2或四个字节。</li>
</ol>
<p>	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:	48 89 f8			mov		%rdi,%rax</span><br><span class="line">3:	eb 03				jmp		8 &lt;loog+0x8&gt;</span><br><span class="line">5:	48 d1 f8			sar		%rax</span><br><span class="line">8:	48 85 c0			test	%rax,%rax</span><br><span class="line">b:	7f f8				jg		5 &lt;loop+0x5&gt;</span><br><span class="line">d:	f3 c3				repz retq</span><br></pre></td></tr></table></figure>

<p>​	右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8,第5行跳转指令的跳转目标是0x5。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码为0x03，把它加上0x5（也就是下一条指令的地址），就能得到跳转目标地址0x8。</p>
<p>​	这些例子说明，当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。（这种惯例可以追溯到早期的实现，当时的处理器<strong>会将更新程序计数器作为执行一条指令的第一步</strong>）</p>
<ol start="2">
<li>第二中编码方法是给出“绝对”地址，用4个字节直接指定目标，汇编器和链接器会选择适当的跳转目的编码。</li>
</ol>
<h2 id="6-控制语句的汇编实现"><a href="#6-控制语句的汇编实现" class="headerlink" title="6. 控制语句的汇编实现"></a>6. 控制语句的汇编实现</h2><h3 id="6-1-条件分支"><a href="#6-1-条件分支" class="headerlink" title="6.1. 条件分支"></a>6.1. 条件分支</h3><h4 id="6-1-1-用条件控制来实现条件分支"><a href="#6-1-1-用条件控制来实现条件分支" class="headerlink" title="6.1.1. 用条件控制来实现条件分支"></a>6.1.1. 用条件控制来实现条件分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test-expr)</span><br><span class="line">	then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">		<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">	then-statement</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">else</span>-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">absdiff_se:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	jge		.L2</span><br><span class="line">	addq	$1, lt_cnt(%rip)</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	ret</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1, ge_cnt(%rip)</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h4 id="6-1-2-用条件传送来实现条件分支"><a href="#6-1-2-用条件传送来实现条件分支" class="headerlink" title="6.1.2. 用条件传送来实现条件分支"></a>6.1.2. 用条件传送来实现条件分支</h4><p>实现条件操作的传统方法是通过使用<em>控制</em>的条件转移。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。</p>
<p>一种体态的策略是使用<em>数据</em>的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。（只有在一些受限制的情况中，这种策略可行，但是如果可行，就可以用一条简单的<em>条件传送</em>指令来实现它）条件传送指令更符合现代处理器的性能特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : <span class="keyword">else</span>-expr;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = then-expr;</span><br><span class="line">ve = <span class="keyword">else</span>-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t) v = ve;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	subq	%rsi, %rdx</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	comvge	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>csapp机械工业出版社，原书第三版，P146，分支预测相关内容。</p>
<p><strong>注意：</strong> 不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，我们给出的抽象代码会对<code>then-expr</code>和<code>else-expr</code>都求值。如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cread</span><span class="params">(<span class="type">long</span> *xp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若将其编译成使用条件传送，当指针为空时，仍将会对其（空指针）进行解引用。</p>
<p><strong>条件传送指令：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>传送条件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cmove        S,  R</td>
<td>cmovz</td>
<td>ZF</td>
<td>相等&#x2F;零</td>
</tr>
<tr>
<td>cmovne      S,  R</td>
<td>cmovnz</td>
<td>~ZF</td>
<td>不等&#x2F;非零</td>
</tr>
<tr>
<td>cmovs         S,  R</td>
<td></td>
<td>SF</td>
<td>负数</td>
</tr>
<tr>
<td>cmovns       S,  R</td>
<td></td>
<td>~SF</td>
<td>非负数</td>
</tr>
<tr>
<td>cmovg         S,  R</td>
<td>cmovnle</td>
<td>(SF ^ OF) &amp; ~ZF</td>
<td>大于(有符号&gt;)</td>
</tr>
<tr>
<td>cmovge       S,  R</td>
<td>cmovnl</td>
<td>~(SF ^ OF)</td>
<td>大于等于(有符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>cmovl          S,  R</td>
<td>cmovnge</td>
<td>SF ^ OF</td>
<td>小于(有符号&lt;)</td>
</tr>
<tr>
<td>cmovle        S,  R</td>
<td>cmovng</td>
<td>(SF ^ OF) | ZF</td>
<td>小于等于(有符号&lt;&#x3D;)</td>
</tr>
<tr>
<td>cmova         S,  R</td>
<td>cmovnbe</td>
<td>~CF &amp; ~ZF</td>
<td>超过(无符号&gt;)</td>
</tr>
<tr>
<td>cmovae       S,  R</td>
<td>cmovnb</td>
<td>~CF</td>
<td>超过或相等(无符号&gt;&#x3D;)</td>
</tr>
<tr>
<td>cmovb         S,  R</td>
<td>cmovnae</td>
<td>CF</td>
<td>低于(无符号&lt;)</td>
</tr>
<tr>
<td>cmovbe       S,  R</td>
<td>setna</td>
<td>CF | ZF</td>
<td>低于或相等(无符号&lt;&#x3D;)</td>
</tr>
</tbody></table>
<ul>
<li>源和目的的值可以是16位，32位或64位长。<strong>不支持单字节的条件传送</strong>。</li>
<li>无条件指令的操作数的长度显式地编码在指令名中，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。</li>
</ul>
<h3 id="6-2-循环语句"><a href="#6-2-循环语句" class="headerlink" title="6.2. 循环语句"></a>6.2. 循环语句</h3><h4 id="6-2-1-do-while循环"><a href="#6-2-1-do-while循环" class="headerlink" title="6.2.1. do-while循环"></a>6.2.1. do-while循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	body-statement</span><br><span class="line">	<span class="title function_">while</span> <span class="params">(test-expr)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fact_do:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg		.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>



<h4 id="6-2-2-while循环"><a href="#6-2-2-while循环" class="headerlink" title="6.2.2. while循环"></a>6.2.2. while循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">	body-statement</span><br></pre></td></tr></table></figure>

<p>while循环有两种翻译方法：</p>
<p><strong>跳转到中间：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">test:</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	jmp		.L5</span><br><span class="line">.L6:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">.L5:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg		.L6</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>

<p><strong>guarded-do：</strong>	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		body-statement</span><br><span class="line">		<span class="title function_">while</span> <span class="params">(test-expr)</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle		.L7</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L6:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jne		.L6</span><br><span class="line">	rep; ret</span><br><span class="line">.L7:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-for循环"><a href="#6-2-3-for循环" class="headerlink" title="6.2.3. for循环"></a>6.2.3. for循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expr; test-expr; update-expr)</span><br><span class="line">	body-statement;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr) &#123;</span><br><span class="line">	body-statement;</span><br><span class="line">	update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8"><span class="top-box-text">第1章 计算机系统漫游</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="top-box-text">第2章 信息的表示和处理</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="top-box-text">第3章 程序的机器级表示</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="top-box-text">1. 数据格式</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="top-box-text">2. 访问信息</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="top-box-text">3. 操作数指示符</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#4-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="top-box-text">4. 数据相关指令</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="top-box-text">4.1. 数据传送指令</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-2-%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="top-box-text">4.2. 压入和弹出栈数据</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-3-%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="top-box-text">4.3. 算术和逻辑操作</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-4-%E7%89%B9%E6%AE%8A%E7%9A%84%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="top-box-text">4.4. 特殊的算术操作</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#5-%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="top-box-text">5. 控制相关指令</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-1-%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="top-box-text">5.1. 条件码</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-2-%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="top-box-text">5.2. 访问条件码</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-3-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="top-box-text">5.3. 跳转指令</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#6-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0"><span class="top-box-text">6. 控制语句的汇编实现</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#6-1-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="top-box-text">6.1. 条件分支</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#6-2-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="top-box-text">6.2. 循环语句</span></a></li></ol></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/11/22/C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6/">
          <h3 class="post-title">
            下一篇：C类型限定符
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/hzrr" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

