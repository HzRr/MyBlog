<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>C_notes</title>
<meta name="keywords" content="C_notes, HzRr&#39;s Blog">
<meta name="description" content="C语言学习笔记数据类型整型C语言中的char型是否为无符号数还是有符号数是Implementation Defined, 由编译器决定。（C标准的Rationale之一：优先考虑效率，而可移植性尚在其次）
如果为了可移植性，就必须写明是si">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="C_notes">
<meta property="og:description" content="C语言学习笔记数据类型整型C语言中的char型是否为无符号数还是有符号数是Implementation Defined, 由编译器决定。（C标准的Rationale之一：优先考虑效率，而可移植性尚在其次）
如果为了可移植性，就必须写明是si">

<link rel="shortcut icon" href="/null">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.svg" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">HzRr&#39;s Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">C_notes</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-10-17</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/C/">
              C
                
                  ，
                
              </a>
            
              <a href="/tags/Note/">
              Note
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>C语言中的char型是否为无符号数还是有符号数是Implementation Defined, 由编译器决定。（<strong>C标准的Rationale之一：优先考虑效率，而可移植性尚在其次</strong>）</p>
<p>如果为了可移植性，就必须写明是signed还是unsigned。<br>整形还包括: short int, int, long int, long long int等几种</p>
<p>对于<strong>有符号数</strong>在计算机中的表示是Sign and Magnitude、1’s Complement还是2’s Complement, C标准也没有明确规定，也是Implementation Defined。（<strong>大多数体系结构都采用2’s Complement表示法，x86平台也是如此</strong>）</p>
<p>除了char型在C标准中明确规定占一个字节之外，其它整型占几个字节都是Implementation Defined。通常的编译器实现遵守ILP32或LP64规范，如下表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>ILP32（位数）</th>
<th>LP64（位数）</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>64</td>
</tr>
<tr>
<td>pointer</td>
<td>32</td>
<td>64</td>
</tr>
</tbody></table>
<p>ILP32这个缩写的意思是int（I）、long（L）和指针（P）类型都占32位，通常32位计算机的C编译器采用这种规范，x86平台的gcc也是如此。LP64是指long（L）和指针占64位，通常64位计算机的C编译器采用这种规范。</p>
<p>C标准规定的浮点型有float、double、long double，和整型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大，有的处理器有浮点运算单元（FPU，Floating Point Unit），称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单元，只能做整数运算，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。大部分平台的浮点数实现遵循IEEE 754，float型通常是32位，double型通常是64位。</p>
<p>long double型通常是比double型精度更高的类型，但各平台的实现有较大差异。在x86平台上，大多数编译器实现的long double型是80位，因为x86的浮点运算单元具有80位精度，gcc实现的long double型是12字节（96位），<strong>这是为了对齐到4字节边界</strong>，也有些编译器实现的long double型和double型精度相同，没有充分利用x86浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上的long double型通常是128位。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch15s03.html">直达链接</a></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h3><p>声明指针时，最好要同时初始化指针，我们知道，在堆栈上分配的变量初始值是不确定的，也就是说指针<code>p</code>所指向的内存地址是不确定的，后面用<code>*p</code>访问不确定的地址就会导致不确定的后果，如果导致段错误还比较容易改正，如果意外改写了数据而导致随后的运行中出错，就很难找到错误原因了。像这种指向不确定地址的指针称为“野指针”（Unbound Pointer），为避免出现野指针，在定义指针变量时就应该给它明确的初值，或者把它初始化为<code>NULL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	...</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NULL</code>在C标准库的头文件<code>stddef.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>

<p>就是把地址0转换成指针类型，称为空指针，它的特殊之处在于，操作系统不会把任何数据保存在地址0及其附近，也不会把地址0~0xfff的页面映射到物理内存，所以任何对地址0的访问都会立刻导致段错误。<code>*p = 0;</code>会导致段错误，就像放在眼前的炸弹一样很容易找到，相比之下，野指针的错误就像埋下地雷一样，更难发现和排除，这次走过去没事，下次走过去就有事。</p>
<h3 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h3><p><code>void *</code>类型，相当于中间桥梁，<code>void *</code>指针与其它类型的指针之间可以隐式转换，而不必用类型转换运算符。</p>
<p><code>void *</code>指针所占内存大小同样是一个word，但其不能进行解引用(Dereference)，因为编译器不知道要分配多少个字节给变量</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组名做右值时，自动转换成指向数组首元素的指针</p>
<p>在指针数组中，可以将最后一个元素设为NULL，即空指针，方便遍历数组时更优雅地设置循环结束条件，即<code>arr[i] != NULL</code>，<code>NULL</code>标识着<code>arr</code>的结尾，这个循环碰到<code>NULL</code>就结束，因而不会访问越界，这种用法很形象地称为Sentinel，<code>NULL</code>就像一个哨兵守卫着数组的边界。</p>
<p><strong>btw:</strong>  index[arr_name] 的写法也是正确的，只不过不建议这么写 </p>
<blockquote>
<p>事实上，E1[E2]这种写法和(<em>((E1)+(E2)))是等价的，</em>(pa+2)也可以写成pa[2]，pa就像数组名一样，其实数组名也没有什么特殊的，a[2]之所以能取数组的第2个元素，是因为它等价于*(a+2)，在第 1 节 “数组的基本概念”讲过数组名做右值时自动转换成指向首元素的指针，所以a[2]和pa[2]本质上是一样的，都是通过指针间接寻址访问元素。由于(<em>((E1)+(E2)))显然可以写成(</em>((E2)+(E1)))，所以E1[E2]也可以写成E2[E1]，这意味着2[a]、2[pa]这种写法也是对的，但一般不这么写。</p>
</blockquote>
<h2 id="指向常量的指针和常量指针"><a href="#指向常量的指针和常量指针" class="headerlink" title="指向常量的指针和常量指针"></a>指向常量的指针和常量指针</h2><ol>
<li><p><strong>指向常量的指针</strong>：这是一个指针，它指向的对象不能通过这个指针来修改，但指针自身可以指向其它对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr1;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr1;</span><br></pre></td></tr></table></figure>

<p>这意味着，你不能使用<code>ptr1</code>来修改它所指向的整数值，但是你可以更改<code>ptr1</code>使其指向其他整数。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr1 = &amp;x;</span><br><span class="line"><span class="comment">// *ptr1 = 15; // 这是错误的，因为ptr1指向一个常量</span></span><br><span class="line">ptr1 = &amp;y; <span class="comment">// 这是正确的，因为ptr1自身可以改变指向</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常量指针</strong>：这是一个常量，它的指向不能改变，但它指向的对象可以被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr2;</span><br></pre></td></tr></table></figure>

<p>这意味着，你不能更改<code>ptr2</code>的指向，但是你可以使用<code>ptr2</code>来修改它所指向的整数值。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr2 = &amp;x;</span><br><span class="line">*ptr2 = <span class="number">15</span>; <span class="comment">// 这是正确的，因为可以通过ptr2修改它指向的整数值</span></span><br><span class="line"><span class="comment">// ptr2 = &amp;y; // 这是错误的，因为ptr2的指向不能改变</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指向常量的常量指针</strong>：这是一个常量指针，指向一个常量，因此既不能通过该指针修改所指向的对象，也不能更改指针的指向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ptr3;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些声明之间的差异在于”const”关键字的位置，这决定了哪部分是常量：是指针本身还是它指向的对象</p>
<p>即使不用<code>const</code>限定符也能写出功能正确的程序，但良好的编程习惯应该尽可能多地使用<code>const</code>，因为：</p>
<ol>
<li><code>const</code>给读代码的人传达非常有用的信息。比如一个函数的参数是<code>const char *</code>，你在调用这个函数时就可以放心地传给它<code>char *</code>或<code>const char *</code>指针，而不必担心指针所指的内存单元被改写。</li>
<li>尽可能多地使用<code>const</code>限定符，把不该变的都声明成只读，这样可以依靠编译器检查程序中的Bug，防止意外改写数据。</li>
<li><code>const</code>对编译器优化是一个有用的提示，编译器也许会把<code>const</code>变量优化成常量。</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch19s03.html#asmc.layout">第 3 节 “变量的存储布局”</a>我们看到，字符串字面值通常分配在<code>.rodata</code>段，而在<a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch08s04.html#array.string">第 4 节 “字符串”</a>提到，字符串字面值类似于数组名，做右值使用时自动转换成指向首元素的指针，这种指针应该是<code>const char *</code>型。我们知道<code>printf</code>函数原型的第一个参数是<code>const char *</code>型，可以把<code>char *</code>或<code>const char *</code>指针传给它，所以下面这些调用都是合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(str1);</span><br><span class="line"><span class="built_in">printf</span>(str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意上面第一行，如果要定义一个指针指向字符串字面值，这个指针应该是<code>const char *</code>型，如果写成<code>char *p = &quot;abcd&quot;;</code>就不好了，有隐患，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">...</span><br><span class="line">	*p = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p</code>指向<code>.rodata</code>段，不允许改写，但编译器不会报错，在运行时会出现段错误。</p>
<h2 id="指向数组的指针和多维数组"><a href="#指向数组的指针和多维数组" class="headerlink" title="指向数组的指针和多维数组"></a>指向数组的指针和多维数组</h2><h3 id="指向数组的指针与指针数组"><a href="#指向数组的指针与指针数组" class="headerlink" title="指向数组的指针与指针数组"></a>指向数组的指针与指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*a)[<span class="number">10</span>];	<span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="type">int</span> *a[<span class="number">10</span>];		<span class="comment">// 指针数组</span></span><br></pre></td></tr></table></figure>



<h3 id="指向数组的指针的使用"><a href="#指向数组的指针的使用" class="headerlink" title="指向数组的指针的使用"></a>指向数组的指针的使用</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure>

<p><code>a</code>是一个数组，在<code>&amp;a</code>这个表达式中，数组名做左值，取整个数组的首地址赋给指针<code>pa</code>。注意，<code>&amp;a[0]</code>表示数组<code>a</code>的首元素的首地址，而<code>&amp;a</code>表示数组<code>a</code>的首地址，显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型，前者的类型是<code>int *</code>，而后者的类型是<code>int (*)[10]</code>。</p>
<p>先将指针<code>pa</code>解引用后进行索引取值<code>*pa[index]</code>，<code>pa[0] </code>则是对这个指针所指向的数组的引用, 因此也可直接使用<code>pa[0][index]</code>来访问数组元素</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p><code>a</code>是由<code>int [10]</code>组成的数组，<code>pa</code>则是指向这种元素的指针。所以，如果<code>pa</code>指向<code>a</code>的首元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5][10];</span><br><span class="line">int (*pa)[10] = &amp;a[0];</span><br></pre></td></tr></table></figure>

<p>则<code>pa[0]</code>和<code>a[0]</code>取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个<code>int</code>组成的数组，而不是基本类型。这样，我们可以把<code>pa</code>当成二维数组名来使用，<code>pa[1][2]</code>和<code>a[1][2]</code>取的也是同一个元素，而且<code>pa</code>比<code>a</code>用起来更灵活，数组名不支持赋值、自增等运算，而指针可以支持，<code>pa++</code>使<code>pa</code>跳过二维数组的一行（40个字节），指向<code>a[1]</code>的首地址。</p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>1、定义以下变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">4</span>][<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;&#125;,</span><br><span class="line">		   &#123;&#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>&#125;, &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;, &#123;<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;&#125;,</span><br><span class="line">		   &#123;&#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;, &#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>&#125;, &#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;&#125;,</span><br><span class="line">		   &#123;&#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;, &#123;<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> (*pa)[<span class="number">2</span>] = &amp;a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="type">char</span> (*ppa)[<span class="number">3</span>][<span class="number">2</span>] = &amp;a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>要想通过<code>pa</code>或<code>ppa</code>访问数组<code>a</code>中的<code>&#39;r&#39;</code>元素，分别应该怎么写？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> a[<span class="number">4</span>][<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;&#125;,</span><br><span class="line">                   &#123;&#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>&#125;, &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;, &#123;<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;&#125;,</span><br><span class="line">                   &#123;&#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;, &#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>&#125;, &#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;&#125;,</span><br><span class="line">                   &#123;&#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;, &#123;<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> (*pa)[<span class="number">2</span>] = &amp;a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">char</span> (*ppa)[<span class="number">3</span>][<span class="number">2</span>] = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pa[<span class="number">5</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ppa[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="top-box-text">C语言学习笔记</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="top-box-text">数据类型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B4%E5%9E%8B"><span class="top-box-text">整型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="top-box-text">类型转换</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8C%87%E9%92%88"><span class="top-box-text">指针</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="top-box-text">指针初始化</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%80%9A%E7%94%A8%E6%8C%87%E9%92%88"><span class="top-box-text">通用指针</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="top-box-text">指针与数组</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="top-box-text">指向常量的指针和常量指针</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="top-box-text">指向数组的指针和多维数组</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="top-box-text">指向数组的指针与指针数组</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="top-box-text">指向数组的指针的使用</span></a></li></ol></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/10/17/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%BD%9C%E4%B8%9A/">
          <h3 class="post-title">
            下一篇：图灵机作业
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/hzrr" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

